#include <SPI.h>
#include "SdFat.h"
#include "sdios.h"
#include <Wire.h>
#include <RCSwitch.h>
#include <stdint.h>
#include <IRremote.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>
#include <Adafruit_PN532.h>
#include <string.h>
#include "Keyboard.h"

// IR receiver setup
#define IR_RECEIVE_PIN 6  // Pin for receiving IR signals
#define IR_SEND_PIN 9     // Pin for sending IR signals
int freq_ir = 38;         // IR signal frequency
String irproducer = "";   // IR signal producer string
uint16_t rawData[67];     // Array to hold raw IR data
String data = "";         // String to hold data from IR signal
int scanning = 1;         // Variable to indicate scanning state

// SD card variables
#define SPI_SPEED SD_SCK_MHZ(4)  // Speed of SPI communication
#define SD_PIN A0                // Pin for SD card communication
SdFat SD;                        // SD card object
File file;                       // File object for SD card
bool sdbegin = false;            // Flag to check if SD card is initialized
char fileName[50];               // Filename buffer
char selectedFile[50];           // Selected file buffer
int type = 0;                    // Variable to hold type
int sceltaSd = 0;                // Choice for SD card options
int selectedFileNumber = 1;      // Selected file number
int fileCount = 0;               // Number of files (function to count files is needed)
String buffer;                   // String buffer for file data

// Button pin definitions
#define buttonUp (A4)
#define buttonDown (A0)
#define buttonLeft (A3)
#define buttonSelect (A2)
#define buttonRight (A1)

// Initial menu variables
int currentPage = 0;     // Current page of the main menu
int scelta = 0;          // Selected option from the main menu
const int numPages = 5;  // Total number of pages in the main menu

// Sub-menu variables
int currentPageSubMenu = 0;  // Current page in the sub-menu
int sceltaSubMenu = 0;       // Selected option from the sub-menu
int numPagesSubMenu = 3;     // Total number of pages in the sub-menu

// "Tamaguino" variables (for some game or device control)
const int sound = 0;  // Pin for sound output
#define button1Pin (A3)
#define button2Pin (A5)                                            
#define button3Pin (A2)
int button1State = 0;  // State of button 1
int button2State = 0;  // State of button 2
int button3State = 0;  // State of button 3
#define ACTIVATED LOW  // Define button "activated" state

// Battery variables
#define analogInPin A4     // Pin for analog input to measure battery
int sensorValue;           // Value from battery sensor
float calibration = 2.25;  // Calibration value for battery percentage
int bat_percentage;        // Battery percentage

// RFID card variables for unlocking
int buf[] = { 115, 232, 15, 186 };  // Array holding card data
bool tag = false;                   // Tag flag (if a card is detected)

// RF (Radio Frequency) definitions
#define rfreceive 3              // Pin to receive RF signals
#define rftransmit A6            // Pin to transmit RF signals
RCSwitch mySwitch = RCSwitch();  // RF switch object
int rfvalue;                     // RF value received
int rfbit;                       // RF bit value
int rfprotocol;                  // RF protocol used

// RFID pin definitions
#define IRQ 1    // IRQ pin for RFID communication
#define RESET 0  // Reset pin for RFID communication

// RFID/NFC variables
Adafruit_PN532 nfc(IRQ, RESET, &Wire);    // RFID/NFC object
uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };  // UID buffer for RFID tag
uint8_t uidLength;                        // UID length (either 4 or 7 bytes)

// Display setup
Adafruit_SSD1306 display(128, 64);  // OLED display object (128x64 resolution)

void setup() {
  Serial.begin(115200);  // Initialize serial communication
  Wire.begin();          // Initialize I2C communication

  // Setup button pins as input with internal pull-up resistors
  pinMode(buttonUp, INPUT_PULLUP);
  pinMode(buttonDown, INPUT_PULLUP);
  pinMode(buttonLeft, INPUT_PULLUP);
  pinMode(buttonSelect, INPUT_PULLUP);
  pinMode(buttonRight, INPUT_PULLUP);

  // Setup "Tamaguino" buttons and sound pin
  pinMode(button1Pin, INPUT_PULLUP);
  pinMode(button2Pin, INPUT_PULLUP);
  pinMode(button3Pin, INPUT_PULLUP);
  pinMode(sound, OUTPUT);  // Set sound pin as output

  // Setup OLED display
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // Initialize display with address 0x3C
  display.setTextColor(WHITE);                // Set text color to white
  flopperblockedimage();                      // Display image on screen 

  // Setup RF communication
  mySwitch.enableReceive(rfreceive);    // Enable RF reception
  mySwitch.enableTransmit(rftransmit);  // Enable RF transmission

  // Setup IR receiver and sender
  IrReceiver.begin(IR_RECEIVE_PIN);  // Initialize IR receiver
  IrSender.begin(IR_SEND_PIN);       // Initialize IR sender

  // Setup RFID/NFC communication
  nfc.begin();                                      // Initialize NFC
  uint32_t versiondata = nfc.getFirmwareVersion();  // Get RFID firmware version
  if (!versiondata) {
    Serial.println("RFID error");  // If no RFID detected, print error
    display.setCursor(33, 30);     // Display error on screen
    display.println("RFID error");
    display.display();
    //while (1);  // Uncomment this to stop execution if RFID is not detected
  }
  nfc.SAMConfig();  // Configure NFC for SAM mode

  // Setup SD card
  if (SD.begin(SD_PIN, SPI_SPEED)) {
    sdbegin = true;  // SD card successfully initialized
    Serial.println("SD");
  } else {
    sdbegin = false;  // SD card initialization failed
    Serial.println("NO SD");
  }
}

void loop() {
  switch (scelta) {  // Main loop to handle different modes based on user choice
    case 0:
      displayMenu();  // Display the menu
      break;
    case 1:
      badusb();  // Handle bad USB functionality 
      break;
    case 2:
      rfid();  // Handle RFID functionality 
      break;
    case 3:
      ir();  // Handle IR functionality 
    case 4:
      rf();  // Handle RF functionality 
      break;
    default:
      currentPage = 0;  // Reset to the first page of the menu
      scelta = 0;       // Reset selected option
      break;
  }
}


void displayMenu() {

  // If the tag is detected (tag == true), try to read the RFID/NFC tag
  if (tag == true) {
    uint8_t success;
    uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };  // Buffer to store the returned UID
    uint8_t uidLength;                        // Length of the UID (4 or 7 bytes depending on ISO14443A card type)

    // Attempt to read the passive NFC tag's UID using PN532 reader
    success = nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &uidLength);

    // If the tag is successfully read
    if (success) {
      Serial.print("UID Value: ");
      nfc.PrintHex(uid, uidLength);  // Print the UID value in hexadecimal format

      // Check if the UID matches a predefined buffer (buf) for verification
      for (int i = 0; i < 4; i++) {
        // Compare the first 4 bytes of the UID with the buf array
        if (uid[i] == buf[i]) {
          tag = true;  // Set tag as true if there's a match
        } else {
          tag = false;  // If any byte doesn't match, set tag to false
          break;        // Exit the loop if there's no match
        }
      }
    }

    // If no tag is detected (tag == false), check for menu button input
  } else {
    checkMenuButton();  // Function to handle menu button interactions

    // Switch case to determine which page/menu to display
    switch (currentPage) {
      case 0:
        menuprincipale();  // Show the main menu (Tamagotchi-like menu)
        break;
      case 1:
        menuusb();  // Display USB-related menu
        break;
      case 2:
        menurfid();  // Display RFID-related menu
        break;
      case 3:
        menuir();  // Display IR (Infrared) related menu
        break;
      case 4:
        menurf();  // Display RF (Radio Frequency) related menu
        break;
    }
  }
}








// The rf function handles the RF menu options
void rf() {
  type = 4;  // Set the type to indicate RF functionality
  switch (sceltaSubMenu) {
    case 0:
      subMenuDisplay();  // Display the submenu options
      break;
    case 1:
      scanRf();  // Start the RF scanning process
      break;
    case 2:
      sdMenuDisplay(4);  // Display the SD card menu for RF options
      break;
  }
}

//+=============================================================================
// Scan for RF signals and display the received information
//
void scanRf() {
  if (scanning == 1) {                                // Check if scanning is active
    graficascan();                                    // Update the display with scanning graphics
    if (mySwitch.available()) {                       // Check if a new RF signal is available
      Serial.print("Received ");                      // Print received RF value to Serial Monitor
      Serial.println(mySwitch.getReceivedValue());    // Print the value received
      Serial.print(mySwitch.getReceivedBitlength());  // Print the bit length of the received value
      Serial.println(" bit ");
      Serial.print("Protocol: ");                      // Print the protocol used for the RF signal
      Serial.println(mySwitch.getReceivedProtocol());  // Print the received protocol
      rfvalue = mySwitch.getReceivedValue();           // Store the received value
      rfbit = mySwitch.getReceivedBitlength();         // Store the bit length of the received value
      rfprotocol = mySwitch.getReceivedProtocol();     // Store the protocol used
      mySwitch.resetAvailable();                       // Reset the availability of the RF signal
      scanning = 0;                                    // Stop scanning
    }
  } else {
    scanbase();                                         // Display base information if not scanning
    display.setCursor(25, 25);                          // Set cursor position on the display
    display.println("Value " + String(rfvalue));        // Display the received RF value
    display.setCursor(20, 35);                          // Set cursor position for bit length display
    display.println("Bit " + String(rfbit));            // Display the bit length
    display.setCursor(60, 35);                          // Set cursor position for protocol display
    display.println("Protocol " + String(rfprotocol));  // Display the RF protocol used
  }
  battery();             // Display battery status
  checkModuleButton(4);  // Check the status of the module button
}

// Function to emulate RF transmission
void emulateRf() {
  scanbase();                     // Display base information
  display.setCursor(33, 30);      // Set cursor position to indicate sending
  display.println("Sending...");  // Display sending message
  battery();                      // Display battery status
  mySwitch.send(rfvalue, rfbit);  // Send the stored RF value and bit length
  delay(2000);                    // Wait for 2 seconds to allow transmission to complete
}

// Function to save the received RF data to an SD card
void saveRf() {
  scanbase();                          // Display base information
  if (scanning == 0) {                 // Proceed only if not currently scanning
    if (sdbegin) {                     // Check if SD card is initialized
      display.setCursor(33, 30);       // Set cursor position for saving message
      display.println("Saving...");    // Display saving message
      for (int i = 0; i < 100; i++) {  // Loop to find an available file slot

        String title;  // Variable to hold the file name
        // Generate the file name based on the index
        if (i < 10 && i >= 0) {
          title = "/rf/rf_0" + String(i) + ".txt";  // Format for single-digit index
        } else {
          title = "/rf/rf_" + String(i) + ".txt";  // Format for double-digit index
        }

        // Check if the file already exists on the SD card
        if (SD.exists(title)) {
          // Uncomment below to display message if file exists
          //display.setCursor(33, 30);
          //display.println("Already exists");  // Indicate that the file already exists
        } else {
          file = SD.open(title, FILE_WRITE);  // Open the file for writing
          file.println(rfvalue);              // Write the RF value to the file
          file.println(rfbit);                // Write the bit length to the file
          file.println(rfprotocol);           // Write the protocol to the file
          file.close();                       // Close the file after writing
          break;                              // Exit the loop after saving the data
        }
      }
    } else {
      display.setCursor(33, 30);       // Set cursor position for SD error message
      display.println("SD Error...");  // Display SD card error message
    }
  } else {
    display.setCursor(30, 30);           // Set cursor position for no data message
    display.println("Nothing to send");  // Indicate there is no RF data to send
  }
  battery();    // Display battery status
  delay(2000);  // Wait for 2 seconds before the next action
}











// The rfid function handles the RFID menu options
void rfid() {
  type = 2;  // Set the type to indicate RFID functionality
  switch (sceltaSubMenu) {
    case 0:
      subMenuDisplay();  // Display the submenu options
      break;
    case 1:
      scanRfid();  // Start the RFID scanning process
      break;
    case 2:
      sdMenuDisplay(2);  // Display the SD card menu for RFID options
      break;
  }
}

//+=============================================================================
// Scan for RFID tags and display the received information
//
void scanRfid() {
  if (scanning == 1) {  // Check if scanning is active
    graficascan();      // Update the display with scanning graphics
    battery();          // Display the battery status

    // Universal key for NDEF and Mifare Classic communication
    uint8_t keyuniversal[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
    uint8_t success;                                                             // Variable to hold success status of the RFID read operation
    success = nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &uidLength);  // Read RFID tag

    if (success) {  // If a tag is found
      scanbase();   // Display base information
      // Display some basic information about the found card
      Serial.println("Found an ISO14443A card");  // Print card type to Serial Monitor
      Serial.print("  UID Length: ");             // Print UID length message
      Serial.print(uidLength, DEC);               // Print UID length in decimal
      Serial.println(" bytes");                   // Print bytes label
      Serial.print("  UID Value: ");              // Print UID value message
      nfc.PrintHex(uid, uidLength);               // Print UID value in hexadecimal format
      Serial.println("");                         // New line for clarity

      // Display UID value on the screen
      display.setCursor(20, 25);             // Set cursor position for UID display
      display.print("UID: ");                // Print UID label
      for (int i = 0; i < uidLength; i++) {  // Loop through UID bytes
        if (i + 1 != uidLength) {            // If not the last byte
          display.print(uid[i]);             // Print UID byte
        } else {
          display.println(uid[i]);  // Print last UID byte with new line
        }
      }
      display.setCursor(15, 35);                                 // Set cursor position for length display
      display.print("Length: " + String(uidLength) + " Bytes");  // Display UID length
      scanning = 0;                                              // Stop scanning after reading UID
    }
  } else {
    scanbase();                            // Display base information if not currently scanning
    display.setCursor(20, 25);             // Set cursor position for UID display
    display.print("UID: ");                // Print UID label
    for (int i = 0; i < uidLength; i++) {  // Loop through UID bytes
      if (i + 1 != uidLength) {            // If not the last byte
        display.print(uid[i]);             // Print UID byte
      } else {
        display.println(uid[i]);  // Print last UID byte with new line
      }
    }
    display.setCursor(15, 35);                                 // Set cursor position for length display
    display.print("Length: " + String(uidLength) + " Bytes");  // Display UID length
  }
  battery();             // Display battery status
  checkModuleButton(2);  // Check the status of the module button
}

// Function to emulate RFID transmission
void emulateRfid() {
  uint8_t apdubuffer[255] = {}, apdulen = 0;  // Buffer for APDU data and its length
  // PPSE APDU data to mimic a smart card response
  uint8_t ppse[] = { 0x8E, 0x6F, 0x23, 0x84, 0x0E, 0x32, 0x50, 0x41, 0x59, 0x2E,
                     0x53, 0x59, 0x53, 0x2E, 0x44, 0x44, 0x46, 0x30, 0x31,
                     0xA5, 0x11, 0xBF, 0x0C, 0x0E, 0x61, 0x0C, 0x4F, 0x07,
                     0xA0, 0x00, 0x00, 0x00, 0x03, 0x10, 0x10, 0x87,
                     0x01, 0x01, 0x90, 0x00 };
  nfc.AsTarget();                                 // Set the NFC device as the target
  (void)nfc.getDataTarget(apdubuffer, &apdulen);  // Read initial APDU data
  if (apdulen > 0) {                              // If APDU data is received
    for (uint8_t i = 0; i < apdulen; i++) {       // Loop through the APDU data
      Serial.print(" 0x");                        // Print prefix for hex values
      Serial.print(apdubuffer[i], HEX);           // Print APDU byte in hexadecimal
    }
    Serial.println("");  // New line for clarity
  }
  nfc.setDataTarget(ppse, sizeof(ppse));     // Mimic a smart card response with PPSE APDU
  nfc.getDataTarget(apdubuffer, &apdulen);   // Read response from the Point of Sale (PoS) or terminal
  if (apdulen > 0) {                         // If APDU response data is received
    for (uint8_t i = 0; i < apdulen; i++) {  // Loop through the response data
      Serial.print(" 0x");                   // Print prefix for hex values
      Serial.print(apdubuffer[i], HEX);      // Print response byte in hexadecimal
    }
    Serial.println("");  // New line for clarity
  }
  delay(1000);  // Wait for 1 second before the next operation
}

// Function to save RFID data to an SD card
void saveRfid() {
  scanbase();                        // Display base information
  if (scanning == 0) {               // Proceed only if not currently scanning
    if (sdbegin) {                   // Check if SD card is initialized
      display.setCursor(33, 30);     // Set cursor position for saving message
      display.println("Saving...");  // Display saving message
      // Check if the file "prova.txt" already exists on the SD card
      if (SD.exists("ir/prova.txt")) {
        Serial.println("Already exists");  // Print message indicating the file already exists
      } else {
        file = SD.open("ir/prova.txt", FILE_WRITE);  // Open the file for writing
        for (int i = 0; i < 67; i++) {               // Loop to write data to the file
          file.print("ciao");                        // Write "ciao" to the file
        }
        file.close();  // Close the file after writing
      }
    } else {
      display.setCursor(33, 30);       // Set cursor position for SD error message
      display.println("SD Error...");  // Display SD card error message
    }
  } else {
    display.setCursor(30, 30);           // Set cursor position for no data message
    display.println("Nothing to send");  // Indicate there is no RFID data to send
  }
  battery();    // Display battery status
  delay(2000);  // Wait for 2 seconds before the next action
}













// Function to handle the SD menu display
// It checks if a file is selected, if not, it calls the checkSdButton() function to handle navigation
void sdMenuDisplay(int wichType) {
  if (sceltaSd == 0) {
    checkSdButton();  // Check for button presses in the SD menu
  } else {
    if (sceltaSd >= 1) {
      selectedSd(wichType);  // If a file is selected, proceed to handle that file
    }
  }
}

// Function to display files from the SD card on the screen
// It calculates the number of pages, and current page based on the file count and selected file
void sdDisplay(File dir, int wichType) {
  int i = 1;  // Counter to keep track of files

  int pages = fileCount / 6;  // Calculate the number of pages (6 files per page)
  int add = fileCount % 6;    // Remainder to handle cases where files don't fit perfectly on pages
  if (add > 0) {
    pages = pages + 1;  // Add an extra page if there are leftover files
  }
  int currentPage = selectedFileNumber / 6;     // Calculate the current page based on the selected file number
  int addCurrentPage = selectedFileNumber % 6;  // Check if the selected file fits within a complete page
  if (addCurrentPage > 0) {
    currentPage = currentPage + 1;  // Adjust current page if there's an incomplete page
  }

  // Display the current page and total number of pages in the serial monitor (for debugging purposes)
  Serial.print("Pages:");
  Serial.println(pages);
  Serial.print("Current page:");
  Serial.println(currentPage);

  // Clear the screen and prepare for new content
  display.clearDisplay();
  display.drawBitmap(0, 0, frame, 128, 64, WHITE);  // Draw a frame or border on the screen
  int positionText = 4;                             // Initial Y position for the text
  display.setCursor(10, positionText);              // Set cursor for the display

  // Loop through files and display them on the screen
  while (true) {
    file.openNext(&dir, O_RDONLY);  // Open the next file in the directory
    if (!file || i > currentPage * 6) {
      break;  // Break the loop if there are no more files or if we've reached the last file on the current page
    }
    if (i > currentPage * 6 - 6) {
      file.getName(fileName, sizeof(fileName));  // Get the file name
      if (i == selectedFileNumber) {
        display.print("> ");                // Highlight the selected file with a ">"
        display.println(String(fileName));  // Display the file name
        strcpy(selectedFile, fileName);     // Store the selected file name
      } else {
        display.print("  ");                // Indent for non-selected files
        display.println(String(fileName));  // Display the file name
      }
      file.close();                                             // Close the file after reading its name
      display.setCursor(10, positionText = positionText + 10);  // Move the cursor down for the next file
    }
    i++;  // Increment file counter
  }

  display.display();  // Update the display with the newly rendered content
}

// Function to handle selected file from SD card
// Depending on the "wichType" parameter, different actions are performed based on the file type
void selectedSd(int wichType) {
  switch (wichType) {
    case 1:
      // Action for type 1 can be added here
      break;
    case 2:
      // Action for type 2 can be added here
      break;
    case 3:
      // Action for type 3: Read IR-related data from the selected file
      file = SD.open(String("/ir/") + String(selectedFile));
      if (file) {
        buffer = file.readStringUntil('\n');  // Read the first line from the file
        irproducer = buffer;                  // Store IR producer data
        buffer = file.readStringUntil('\n');  // Read the second line
        data = buffer;                        // Store other data
        buffer = file.readStringUntil('\n');  // Read raw data (as space-separated values)
        memset(rawData, 0, sizeof rawData);   // Clear the rawData array
        int n = 0;                            // Index for parsing the buffer
        for (int k = 0; k < 67; k++) {        // Loop to parse the raw data from the buffer
          String tempData = "";
          while (buffer[n] != ' ') {  // Read until the next space character
            tempData = tempData + buffer[n];
            rawData[k] = tempData.toInt();  // Convert the string to an integer and store it in rawData
            n++;
          }
          n++;  // Move past the space character
        }
        file.close();       // Close the file after reading
        scanning = 0;       // Stop scanning
        sceltaSubMenu = 1;  // Return to the submenu
      }
      break;
    case 4:
      // Action for type 4: Read RF-related data from the selected file
      file = SD.open(String("/rf/") + String(selectedFile));
      if (file) {
        buffer = file.readStringUntil('\n');  // Read the first line
        rfvalue = buffer.toInt();             // Store the RF value
        buffer = file.readStringUntil('\n');  // Read the second line
        rfbit = buffer.toInt();               // Store RF bit data
        buffer = file.readStringUntil('\n');  // Read the third line
        rfprotocol = buffer.toInt();          // Store RF protocol
        file.close();                         // Close the file after reading
        scanning = 0;                         // Stop scanning
        sceltaSubMenu = 1;                    // Return to the submenu
      }
      break;
  }
}

// Function to count the number of files in a directory on the SD card
int countfile(File dir) {
  int fileCount = 0;                       // Initialize file count
  while (file.openNext(&dir, O_RDONLY)) {  // Loop through all files in the directory
    if (!file.isHidden()) {                // Check if the file is not hidden
      fileCount++;                         // Increment file count
    }
    file.close();  // Close the file after counting
  }
  return fileCount;  // Return the total file count
}













// The function that handles the IR menu
void ir() {
  type = 3;                 // Set the type to 3 for IR
  switch (sceltaSubMenu) {  // Check the submenu choice
    case 0:
      subMenuDisplay();  // Display the submenu options
      break;
    case 1:
      scanIr();  // Start scanning for IR signals
      break;
    case 2:
      sdMenuDisplay(3);  // Display the SD card menu for saving IR codes
      break;
  }
}

// Function to scan and display IR code information
void scanIr() {
  if (scanning == 1) {                             // If scanning is active
    graficascan();                                 // Display scan graphic/UI
    decode_results results;                        // Create a structure to store the scan results
    if (IrReceiver.decode(&results)) {             // Decode the IR signal
      dumpInfo(&results);                          // Print information about the signal
      dumpCode(&results);                          // Print the raw IR code in source code format
      Serial.println("");                          // Add a blank line between entries
      scanbase();                                  // Update the base scan screen
      display.setCursor(20, 25);                   // Set display cursor for encoding info
      display.println("Encoding: " + irproducer);  // Show the IR encoding type
      display.setCursor(20, 35);                   // Set display cursor for data info
      display.println("Data: 0x" + data);          // Display the decoded data
      Serial.println(irproducer);                  // Print the encoding type to the Serial Monitor
      IrReceiver.resume();                         // Prepare to receive the next IR code
      scanning = 0;                                // Stop scanning
    }
  } else {
    // If scanning is inactive, just display the last known encoding and data
    scanbase();
    display.setCursor(20, 25);
    display.println("Encoding: " + irproducer);
    display.setCursor(20, 35);
    display.println("Data: 0x" + data);
  }
  battery();             // Check and display battery level
  checkModuleButton(3);  // Check for button inputs in module 3 (IR)
}

// Function to print the IR code in a specific format (for Panasonic codes)
void ircode(decode_results *results) {
  // For Panasonic protocol, print the address
  if (results->decode_type == PANASONIC) {
    Serial.print(results->address, HEX);
    Serial.print(":");
  }

  // Print the value of the IR code
  Serial.print(results->value, HEX);
}

// Function to display the encoding type based on the IR protocol
void encoding(decode_results *results) {
  switch (results->decode_type) {
    default:
    case UNKNOWN:
      irproducer = "UNKNOWN";  // Unknown IR protocol
      Serial.print("UNKNOWN");
      break;
    case NEC:
      irproducer = "NEC";
      Serial.print("NEC");
      break;
    case SONY:
      irproducer = "SONY";
      Serial.print("SONY");
      break;
    case RC5:
      irproducer = "RC5";
      Serial.print("RC5");
      break;
    case RC6:
      irproducer = "RC6";
      Serial.print("RC6");
      break;
    case SHARP:
      irproducer = "SHARP";
      Serial.print("SHARP");
      break;
    case JVC:
      irproducer = "JVC";
      Serial.print("JVC");
      break;
    case BOSEWAVE:
      irproducer = "BOSEWAVE";
      Serial.print("BOSEWAVE");
      break;
    case SAMSUNG:
      irproducer = "SAMSUNG";
      Serial.print("SAMSUNG");
      break;
    case LG:
      irproducer = "LG";
      Serial.print("LG");
      break;
    case WHYNTER:
      irproducer = "WHYNTER";
      Serial.print("WHYNTER");
      break;
    case KASEIKYO:
      irproducer = "KASEIKYO";
      Serial.print("KASEIKYO");
      break;
    case PANASONIC:
      irproducer = "PANASONIC";
      Serial.print("PANASONIC");
      break;
    case DENON:
      irproducer = "DENON";
      Serial.print("Denon");
      break;
  }
}

// Function to display information about the decoded IR signal
void dumpInfo(decode_results *results) {
  // Check if the buffer overflowed
  if (results->overflow) {
    Serial.println("IR code too long. Edit IRremoteInt.h and increase RAWLEN");
    return;
  }

  // Print the encoding type
  Serial.print("Encoding  : ");
  encoding(results);
  Serial.println("");

  // Print the code and the bit length of the IR signal
  Serial.print("Code      : ");
  ircode(results);
  Serial.print(" (");
  Serial.print(results->bits, DEC);
  Serial.println(" bits)");
}

// Function to display the raw IR code in array form for use in source code
void dumpCode(decode_results *results) {
  // Start raw data array declaration
  Serial.print("unsigned int  ");
  Serial.print("rawData[");
  Serial.print(results->rawlen - 1, DEC);  // Print the size of the array
  Serial.print("] = {");                   // Start array declaration

  // Print each value in the raw data buffer
  for (int i = 1; i < results->rawlen; i++) {
    rawData[i - 1] = results->rawbuf[i] * USECPERTICK;  // Convert timing to microseconds
    Serial.print(results->rawbuf[i] * USECPERTICK, DEC);
    if (i < results->rawlen - 1) Serial.print(",");  // Add comma between values except for the last one
    if (!(i & 1)) Serial.print(" ");                 // Add space for readability every two values
  }

  // End array declaration
  Serial.print("};");

  // Add comment with protocol and value
  Serial.print("  // ");
  encoding(results);
  Serial.print(" ");
  ircode(results);

  // Add newline
  Serial.println("");

  // Print known codes (if the type is not UNKNOWN)
  if (results->decode_type != UNKNOWN) {
    // Print address for Panasonic protocol
    if (results->decode_type == PANASONIC) {
      Serial.print("unsigned int  addr = 0x");
      data = String(results->address, HEX);  // Store the address as a string
      Serial.print(results->address, HEX);
      Serial.println(";");
    }

    // Print the data value for all protocols
    Serial.print("unsigned int  data = 0x");
    data = String(results->value, HEX);  // Store the value as a string
    Serial.print(results->value, HEX);
    Serial.println(";");
  }
}

// Function to emulate/simulate sending an IR signal
void emulateIr() {
  scanbase();  // Update the UI for sending
  display.setCursor(33, 30);
  display.println("Sending...");           // Display "Sending..." on the screen
  battery();                               // Display battery level
  IrSender.sendRaw(rawData, 67, freq_ir);  // Send the raw IR code
  delay(2000);                             // Wait for 2 seconds
}

// Function to save an IR code to an SD card
void saveIr() {
  scanbase();           // Update the UI for saving
  if (scanning == 0) {  // Ensure scanning is not active
    if (sdbegin) {      // Check if the SD card is ready
      display.setCursor(33, 30);
      display.println("Saving...");  // Display "Saving..." on the screen

      // Loop through 100 files and find an available filename
      for (int i = 0; i < 100; i++) {
        String title;
        // Generate file name based on the current index
        if (i < 10 && i >= 0) {
          title = "/ir/ir_0" + String(i);  // Create a filename like ir_01.txt
          title = title + ".txt";
        } else {
          title = "/ir/ir_" + String(i);  // Create a filename like ir_10.txt
          title = title + ".txt";
        }

        // Check if the file already exists
        if (SD.exists(title)) {
          // If file exists, continue to next iteration (optional display message commented out)
        } else {
          // Open the file for writing
          file = SD.open(title, FILE_WRITE);
          // Write IR producer and data
          file.println(irproducer);  // Write the encoding type to the file
          file.println(data);        // Write the data to the file

          // Write the raw data values to the file
          for (int i = 0; i < 67; i++) {
            file.print(rawData[i]);  // Print each raw data value
            if (i != 66) {
              file.print(" ");  // Add space between values
            }
          }
          file.print(" ");  // Print an additional space
          file.println();   // Move to the next line
          file.close();     // Close the file after writing
          break;            // Exit the loop after saving the file
        }
      }
    } else {
      // If the SD card is not initialized or has an error
      display.setCursor(33, 30);
      display.println("SD Error...");  // Display an error message
    }
  } else {
    // If scanning is still active, indicate that there's nothing to send
    display.setCursor(30, 30);
    display.println("Nothing to send");  // Display the message
  }
  battery();    // Display battery level
  delay(2000);  // Wait for 2 seconds before the next action
}





//all the function to display the graphics
const unsigned char flopperblocked[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xe3, 0xe0, 0xe3, 0xe0, 0x1f, 0xf3, 0xbe, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xc0, 0x03, 0x87, 0xe0, 0xe3, 0xe0, 0xe3, 0xe0, 0x1f, 0xf3, 0xbe, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xfe, 0x03, 0x87, 0xe0, 0xe3, 0xe0, 0xe3, 0xe0, 0x1f, 0xf3, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xfe, 0x03, 0xb8, 0x1c, 0xfc, 0x1c, 0xfc, 0x1c, 0xe0, 0x73, 0xc1, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xfe, 0x03, 0xb8, 0x1c, 0xfc, 0x1c, 0xfc, 0x1c, 0xe0, 0xf3, 0xc1, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xfc, 0x1c, 0xfc, 0x1c, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 0xff, 0x83, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 0xff, 0x83, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 0xe0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xff, 0xe0, 0xff, 0xe0, 0xe0, 0x73, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xff, 0xe0, 0xff, 0xe0, 0xe0, 0x73, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xff, 0xe0, 0xff, 0xe0, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xf0, 0x00, 0xf0, 0x00, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xe0, 0x00, 0xe0, 0x00, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x1d, 0xce, 0xf8, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x01, 0xce, 0xf8, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x01, 0xc1, 0xcf, 0xfc, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x01, 0xc1, 0xcf, 0x04, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x01, 0xc1, 0xcf, 0x04, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x0e, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x0e, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x0e, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x70, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x70, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x01, 0x81, 0x80, 0x00, 0x60, 0x00, 0x19,
  0x80, 0x70, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x01, 0x81, 0x80, 0x00, 0x62, 0x00, 0x19,
  0x83, 0xff, 0xfd, 0xce, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0x81, 0x8e, 0x1c, 0x66, 0x7c, 0xf9,
  0x83, 0xff, 0xfd, 0xce, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xb9, 0x9e, 0x3e, 0x6c, 0x7c, 0xf9,
  0x83, 0xff, 0xfd, 0xce, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xff, 0xf3, 0xe3, 0x78, 0xff, 0x99,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc7, 0xf3, 0xe1, 0x70, 0xfd, 0x99,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x87, 0xf3, 0xe3, 0x68, 0xc1, 0x99,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x87, 0xf3, 0xe3, 0x6c, 0xcf, 0x99,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf9, 0x9e, 0x3e, 0x66, 0x7f, 0xf9,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x8c, 0x1c, 0x42, 0x3d, 0xf9,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char flopper[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xe3, 0xe0, 0xe3, 0xe0, 0x1f, 0xf3, 0xbe, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xc0, 0x03, 0x87, 0xe0, 0xe3, 0xe0, 0xe3, 0xe0, 0x1f, 0xf3, 0xbe, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xfe, 0x03, 0x87, 0xe0, 0xe3, 0xe0, 0xe3, 0xe0, 0x1f, 0xf3, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xfe, 0x03, 0xb8, 0x1c, 0xfc, 0x1c, 0xfc, 0x1c, 0xe0, 0x73, 0xc1, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xfe, 0x03, 0xb8, 0x1c, 0xfc, 0x1c, 0xfc, 0x1c, 0xe0, 0xf3, 0xc1, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xfc, 0x1c, 0xfc, 0x1c, 0xff, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 0xff, 0x83, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 0xff, 0x83, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xe0, 0x1c, 0xe0, 0x1c, 0xe0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xff, 0xe0, 0xff, 0xe0, 0xe0, 0x73, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0xb8, 0x1c, 0xff, 0xe0, 0xff, 0xe0, 0xe0, 0x73, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xff, 0xe0, 0xff, 0xe0, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xf0, 0x00, 0xf0, 0x00, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x83, 0x80, 0x03, 0x87, 0xe0, 0xe0, 0x00, 0xe0, 0x00, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x1d, 0xce, 0xf8, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x01, 0xce, 0xf8, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x01, 0xc1, 0xcf, 0xfc, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x01, 0xc1, 0xcf, 0x04, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x01, 0xc1, 0xcf, 0x04, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x0e, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x0e, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x0e, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x70, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x70, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x70, 0x01, 0xce, 0x00, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xce, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xce, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xff, 0xfd, 0xce, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char immagineusb[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xbf, 0xff, 0x80, 0x3f, 0xe0, 0xff, 0xfe, 0x00, 0x01, 0xe0, 0x0f, 0x07, 0xff, 0xcf, 0xff, 0xc1,
  0xbf, 0xff, 0x80, 0x3f, 0xe0, 0xff, 0xfe, 0x00, 0x01, 0xe0, 0x0f, 0x07, 0xff, 0xcf, 0xff, 0xe1,
  0xbf, 0xff, 0x80, 0x3f, 0xe0, 0xff, 0xfe, 0x00, 0x01, 0xe0, 0x0f, 0x07, 0xff, 0xcf, 0xff, 0xe1,
  0xbf, 0xff, 0x80, 0x3f, 0xe0, 0xff, 0xfe, 0x00, 0x01, 0xe0, 0x0f, 0x07, 0xff, 0xcf, 0xff, 0xe1,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x7c, 0x00, 0x0f, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x7c, 0x00, 0x0f, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x7c, 0x00, 0x0f, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xff, 0xfe, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x3f, 0xfc, 0x0f, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xff, 0xfe, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x07, 0xfe, 0x0f, 0x00, 0x3d,
  0xbf, 0xff, 0xf3, 0xff, 0xfe, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x07, 0xfe, 0x0f, 0xff, 0xfd,
  0xbf, 0xff, 0x83, 0xff, 0xfe, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x07, 0xfe, 0x0f, 0xff, 0xe1,
  0xbf, 0xff, 0x83, 0xff, 0xfe, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x03, 0xff, 0xcf, 0xff, 0xe1,
  0xbf, 0xff, 0x83, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x00, 0x03, 0xcf, 0xff, 0xe1,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x3d,
  0xbc, 0x00, 0xfb, 0xc0, 0x1e, 0xf0, 0x01, 0xe0, 0x01, 0xe0, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x3d,
  0xbf, 0xff, 0xf3, 0xc0, 0x1e, 0xff, 0xff, 0xe0, 0x01, 0xff, 0xff, 0x3f, 0xff, 0xcf, 0xff, 0xfd,
  0xbf, 0xff, 0x83, 0xc0, 0x1e, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xfe, 0x0f, 0xff, 0xe1,
  0xbf, 0xff, 0x83, 0xc0, 0x1e, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xfe, 0x0f, 0xff, 0xe1,
  0xbf, 0xff, 0x83, 0xc0, 0x1e, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xf0, 0x7f, 0xfe, 0x0f, 0xff, 0xe1,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char immaginerfid[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xff, 0xf0, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xff, 0xf0, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xff, 0xf0, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xff, 0xf0, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x0f, 0xfe, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xfe, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xfe, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x0f, 0xfe, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x0f, 0xfe, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x01, 0xe0, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x01, 0xe0, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x01, 0xe0, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x3e, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x3e, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x3e, 0x0f, 0x00, 0x00, 0x7c, 0x78, 0x01, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x1f, 0xcf, 0x00, 0x00, 0xfe, 0x7f, 0xff, 0xe0, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x00, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x00, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x0f, 0x00, 0x03, 0xcf, 0x00, 0x00, 0xfe, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char immagineir[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x3c, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3c, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3c, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3c, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x3c, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char immaginerf[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0x01, 0xfc, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0x01, 0xfe, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0x01, 0xfe, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0x01, 0xfe, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x03, 0xc0, 0x03, 0xc3, 0xc0, 0x00, 0x00, 0x00, 0xff, 0x1e, 0x03, 0xcf, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x03, 0xc3, 0xc0, 0x00, 0x00, 0x00, 0xff, 0x1e, 0x03, 0xcf, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x03, 0xc3, 0xc0, 0x00, 0x00, 0x00, 0xff, 0x1e, 0x03, 0xcf, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xff, 0xff, 0xc3, 0xff, 0x80, 0x00, 0x07, 0xff, 0x1e, 0x03, 0xce, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0x80, 0x00, 0x07, 0x8f, 0x00, 0x03, 0xc0, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0x80, 0x00, 0x07, 0x8f, 0x00, 0x1f, 0xc0, 0x1f, 0xc0, 0x01,
  0x80, 0x03, 0xff, 0xfe, 0x03, 0xff, 0x80, 0x00, 0x07, 0x8f, 0x00, 0x3e, 0x00, 0x1e, 0x00, 0x01,
  0x80, 0x03, 0xff, 0xfc, 0x03, 0xff, 0x80, 0x00, 0x7f, 0x0f, 0x00, 0x3e, 0x00, 0x1e, 0x00, 0x01,
  0x80, 0x03, 0xc0, 0x78, 0x03, 0xc0, 0x00, 0x00, 0x78, 0x0f, 0x00, 0x3e, 0x00, 0x1e, 0x00, 0x01,
  0x80, 0x03, 0xc0, 0x78, 0x03, 0xc0, 0x00, 0x00, 0x78, 0x0f, 0x00, 0x03, 0xc0, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x78, 0x03, 0xc0, 0x00, 0x00, 0x78, 0x0f, 0x00, 0x03, 0xc0, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x0f, 0x83, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xde, 0x03, 0xcf, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x0f, 0x83, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xde, 0x03, 0xcf, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x0f, 0x83, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xde, 0x03, 0xcf, 0x03, 0xe0, 0x01,
  0x80, 0x03, 0xc0, 0x07, 0xf3, 0xc0, 0x00, 0x00, 0x7f, 0xff, 0xdf, 0xff, 0xcf, 0xff, 0xc0, 0x01,
  0x80, 0x03, 0xc0, 0x00, 0xf3, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xfe, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x03, 0xc0, 0x00, 0xf3, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xfe, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x03, 0xc0, 0x00, 0xf3, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xfe, 0x01, 0xfe, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
//grafica scan
const unsigned char scan[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x11, 0xe0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x13, 0xf0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x17, 0xf8, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x17, 0xf8, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x17, 0xf8, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x9f, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf9,
  0xa0, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x05,
  0xc0, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x03,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x81, 0xc0, 0x00, 0x00, 0x00, 0x57, 0xf8, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x87, 0xc0, 0x00, 0x00, 0x00, 0x57, 0xf8, 0x00, 0x00, 0x00, 0x57, 0x80, 0x00, 0x00, 0x00, 0x01,
  0x8f, 0xc0, 0x00, 0x00, 0x00, 0x57, 0xf8, 0x00, 0x00, 0x00, 0x57, 0xe0, 0x00, 0x00, 0x00, 0x01,
  0xbf, 0xc0, 0x00, 0x00, 0x00, 0x53, 0xf0, 0x00, 0x00, 0x00, 0x57, 0xf0, 0x00, 0x00, 0x00, 0x01,
  0x9f, 0xc0, 0x00, 0x00, 0x00, 0x53, 0xe0, 0x00, 0x00, 0x00, 0x57, 0xf8, 0x00, 0x00, 0x00, 0x01,
  0x8f, 0xc0, 0x00, 0x00, 0x00, 0x51, 0xe0, 0x00, 0x00, 0x00, 0x57, 0xe0, 0x00, 0x00, 0x00, 0x01,
  0x83, 0xc0, 0x00, 0x00, 0x00, 0x50, 0xc0, 0x00, 0x00, 0x00, 0x57, 0xc0, 0x00, 0x00, 0x00, 0x01,
  0x81, 0xc0, 0x00, 0x00, 0x00, 0x50, 0x80, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// 'frame', 128x64px
const unsigned char frame[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


//funnzioni per il menu' principale
void flopperblockedimage() {
  display.clearDisplay();
  display.drawBitmap(0, 0, flopperblocked, 128, 64, WHITE);
  battery();
}

void menuprincipale() {
  display.clearDisplay();
  display.drawBitmap(0, 0, flopper, 128, 64, WHITE);
  battery();
}

void menuusb() {
  display.clearDisplay();
  display.drawBitmap(0, 0, immagineusb, 128, 64, WHITE);
  battery();
}
void menurfid() {
  display.clearDisplay();
  display.drawBitmap(0, 0, immaginerfid, 128, 64, WHITE);
  battery();
}

void menuir() {
  display.clearDisplay();
  display.drawBitmap(0, 0, immagineir, 128, 64, WHITE);
  battery();
}
void menurf() {
  display.clearDisplay();
  display.drawBitmap(0, 0, immaginerf, 128, 64, WHITE);
  battery();
}


//menu' singoli
void graficausb() {
  scanbase();
}

void subMenuDisplay() {
  display.clearDisplay();
  display.drawBitmap(0, 0, frame, 128, 64, WHITE);
  int positionText = 17;
  display.setCursor(10, positionText);
  switch (currentPageSubMenu) {
    case 0:
      currentPageSubMenu = 1;
      display.println("> Scan Signal");
      display.setCursor(10, positionText = positionText + 10);
      display.println("Emulate");
      break;
    case 1:
      display.println("> Scan Signal");
      display.setCursor(10, positionText = positionText + 10);
      display.println("Emulate");
      break;
    case 2:
      display.println("Scan Signal");
      display.setCursor(10, positionText = positionText + 10);
      display.println("> Emulate");
      break;
  }
  battery();
  checkSubMenuButton();
}
void scanbase() {
  display.clearDisplay();
  display.drawBitmap(0, 0, scan, 128, 64, WHITE);
  display.setCursor(55, 5);
  display.println("scan");
  display.setCursor(13, 52);
  display.println("back");
  display.setCursor(55, 52);
  display.println("save");
  display.setCursor(95, 52);
  display.println("emul.");
}
void graficascan() {
  scanbase();
  display.setCursor(33, 30);
  display.println("Scanning...");
}




















// Function to handle button inputs when in the main menu
void checkMenuButton() {
  // Checks if the "Up" button is pressed (via analogRead)
  if (analogRead(buttonUp) == 0) {
    handleUpButton();  // Calls function to handle "Up" action
  }
  // Checks if the "Down" button is pressed (via digitalRead)
  if (digitalRead(buttonDown) == LOW) {
    handleDownButton();  // Calls function to handle "Down" action
  }
  // Checks if the "Left" button is pressed
  if (digitalRead(buttonLeft) == LOW) {
    handleLeftButton();  // Calls function to handle "Left" action
  }
  // Checks if the "Select" button is pressed
  if (digitalRead(buttonSelect) == LOW) {
    handleSelectButton();  // Calls function to handle "Select" action
  }
  // Adds a delay to debounce the buttons
  delay(150);
}

// Function to handle the "Up" button behavior in the main menu
void handleUpButton() {
  // Decrease the current page number if it's greater than the first page
  if (currentPage > 1) {
    currentPage--;
  }
}

// Function to handle the "Down" button behavior in the main menu
void handleDownButton() {
  // Increase the current page number if it's less than the last page
  if (currentPage < numPages - 1) {
    currentPage++;
  }
}

// Function to handle the "Left" button behavior in the main menu
void handleLeftButton() {
  // Resets submenu choice and returns to the main menu
  sceltaSubMenu = 0;
  currentPage = scelta;
  scelta = 0;
}

// Function to handle the "Select" button behavior in the main menu
void handleSelectButton() {
  // Stores the current page as the selected option
  scelta = currentPage;
}

////////////////// Button handling for the second menu ///////////////////

void checkSubMenuButton() {
  // Same logic as the main menu buttons but for the submenu
  if (analogRead(buttonUp) == 0) {
    handleSubMenuUpButton();  // Calls "Up" action for the submenu
  }
  if (digitalRead(buttonDown) == LOW) {
    handleSubMenuDownButton();  // Calls "Down" action for the submenu
  }
  if (digitalRead(buttonLeft) == LOW) {
    handleSubMenuLeftButton();  // Calls "Left" action for the submenu
  }
  if (digitalRead(buttonSelect) == LOW) {
    handleSubMenuSelectButton();  // Calls "Select" action for the submenu
  }
  delay(150);  // Adds delay for button debounce
}

// Function to handle the "Up" button behavior in the submenu
void handleSubMenuUpButton() {
  // Navigate through submenu pages in a circular way
  if (currentPageSubMenu > 0) {
    currentPageSubMenu--;  // Decrease page
  }
  if (currentPageSubMenu == 0) {
    currentPageSubMenu = numPagesSubMenu - 1;  // Wrap around to the last page
  }
}

// Function to handle the "Down" button behavior in the submenu
void handleSubMenuDownButton() {
  // Navigate through submenu pages in a circular way
  if (currentPageSubMenu < numPagesSubMenu - 1) {
    currentPageSubMenu++;  // Increase page
  } else {
    currentPageSubMenu = 0;  // Wrap around to the first page
  }
}

// Function to handle the "Left" button behavior in the submenu
void handleSubMenuLeftButton() {
  // Reset submenu and return to main menu
  sceltaSubMenu = 0;
  currentPage = scelta;
  scelta = 0;
}

// Function to handle the "Select" button behavior in the submenu
void handleSubMenuSelectButton() {
  // Store the current submenu page as the selection
  sceltaSubMenu = currentPageSubMenu;

  // If the selected submenu option is 2, open a directory based on the type
  if (sceltaSubMenu == 2) {
    File dir;  // Declare a file object
    switch (type) {
      case 1:
        dir = SD.open("/badusb/");  // Open the "badusb" directory if type is 1
        break;
      case 2:
        dir = SD.open("/rfid/");  // Open the "rfid" directory if type is 2
        break;
      case 3:
        dir = SD.open("/ir/");  // Open the "ir" directory if type is 3
        break;
      case 4:
        dir = SD.open("/rf/");  // Open the "rf" directory if type is 4
        break;
    }
    // Count files in the opened directory and display them
    fileCount = countfile(dir);
    sdDisplay(dir, type);
  }
}

//////////////////// Button handling for the last module menu //////////////////////////////

void checkModuleButton(int wichMenu) {
  // Start scanning if the "Up" button is pressed
  if (analogRead(buttonUp) == 0) {
    scanning = 1;
  }
  // Execute different save functions depending on the active module (whichMenu)
  if (digitalRead(buttonDown) == LOW) {
    switch (wichMenu) {
      case 1:
        break;  // No action for menu 1
      case 2:
        saveRfid();  // Save RFID data for menu 2
        break;
      case 3:
        saveIr();  // Save IR data for menu 3
        break;
      case 4:
        saveRf();  // Save RF data for menu 4
        break;
    }
  }
  // Handle "Left" button behavior to reset scanning and submenu for each module
  if (digitalRead(buttonLeft) == LOW) {
    sceltaSd = 0;
    selectedFileNumber = 1;
    scanning = 1;
    sceltaSubMenu = 0;
  }
  // Execute emulation functions depending on the module
  if (digitalRead(buttonRight) == LOW) {
    switch (wichMenu) {
      case 1:
        emulateUsb();  // Emulate USB for menu 1
        break;
      case 2:
        emulateRfid();  // Emulate RFID for menu 2
        break;
      case 3:
        emulateIr();  // Emulate IR for menu 3
        break;
      case 4:
        emulateRf();  // Emulate RF for menu 4
        break;
    }
  }
  if (digitalRead(buttonSelect) == LOW) {
    // No action currently set for "Select" in this menu
  }
  delay(150);  // Delay to debounce buttons
}

/////////////////// Button handling for the SD card menu ///////////////////////

void checkSdButton() {
  // Navigate up through files on the SD card when "Up" button is pressed
  if (analogRead(buttonUp) == 0) {
    File dir;  // Declare a file object
    switch (type) {
      case 1:
        dir = SD.open("/badusb/");  // Open the "badusb" directory if type is 1
        break;
      case 2:
        dir = SD.open("/rfid/");  // Open the "rfid" directory if type is 2
        break;
      case 3:
        dir = SD.open("/ir/");  // Open the "ir" directory if type is 3
        break;
      case 4:
        dir = SD.open("/rf/");  // Open the "rf" directory if type is 4
        break;
    }
    // Decrease file selection number or wrap around to the last file
    if (selectedFileNumber > 1) {
      selectedFileNumber--;
      fileCount = countfile(dir);
      sdDisplay(dir, type);
    } else {
      selectedFileNumber = fileCount;
      sdDisplay(dir, type);
    }
  }
  // Navigate down through files on the SD card when "Down" button is pressed
  if (digitalRead(buttonDown) == LOW) {
    File dir;
    switch (type) {
      case 1:
        dir = SD.open("/badusb/");
        break;
      case 2:
        dir = SD.open("/rfid/");
        break;
      case 3:
        dir = SD.open("/ir/");
        break;
      case 4:
        dir = SD.open("/rf/");
        break;
    }
    // Increase file selection number or wrap around to the first file
    if (selectedFileNumber < fileCount) {
      selectedFileNumber++;
      fileCount = countfile(dir);
      sdDisplay(dir, type);
    } else {
      selectedFileNumber = 1;
      sdDisplay(dir, type);
    }
  }

  // Right button doesn't seem to have a function defined in this section
  if (digitalRead(buttonRight) == LOW) {
    // Add any desired function here
  }

  // When "Select" is pressed, set the selected file as the chosen one
  if (digitalRead(buttonSelect) == LOW) {
    sceltaSd = selectedFileNumber;
    if (type == 1) {
      sceltaSubMenu = 1;  // Specific action for type 1 in SD menu
    }
  }

  // When "Left" button is pressed, reset the file selection and exit the SD menu
  if (digitalRead(buttonLeft) == LOW) {
    sceltaSubMenu = 0;
    selectedFileNumber = 1;
    sceltaSd = 0;
  }

  // Delay for button debouncing
  delay(150);
}











void battery() {
  // Read the analog value from the sensor pin
  sensorValue = analogRead(analogInPin);

  // Convert the analog sensor value to a voltage.
  // The factor of 2 accounts for the voltage divider (100K & 100K resistors).
  // Subtract calibration to adjust the voltage reading.
  float voltage = (((sensorValue * 3.3) / 1024) * 2 - calibration);

  // Map the voltage value to a percentage (0% at 2.8V, 100% at 4.2V).
  bat_percentage = mapfloat(voltage, 2.8, 4.2, 0, 100);

  // Ensure battery percentage stays within 0-100% range
  if (bat_percentage >= 100) {
    bat_percentage = 100;  // Cap the percentage at 100%
  }
  if (bat_percentage <= 0) {
    bat_percentage = 1;  // Prevent percentage from being less than 1%
  }

  /*
  // Uncomment for debugging:
  // Print the analog value, voltage, and battery percentage to the serial monitor.
  // Serial.print("Analog Value = ");
  // Serial.print(sensorValue);
  // Serial.print("\t Output Voltage = ");
  // Serial.print(voltage);
  // Serial.print("\t Battery Percentage = ");
  // Serial.println(bat_percentage);
  */

  // Adjust the display cursor position based on the length of the percentage value.
  if (bat_percentage < 100 && bat_percentage > 10) {
    display.setCursor(105, 5);  // Set cursor for 2-digit percentage
  } else {
    if (bat_percentage < 10) {
      display.setCursor(110, 5);  // Set cursor for 1-digit percentage
    } else {
      display.setCursor(100, 5);  // Set cursor for 100%
    }
  }

  // Display the battery percentage on the screen
  display.print(bat_percentage);
  display.println("%");
  display.display();  // Refresh the display with the new data
}

// This function maps a floating-point value from one range to another.
// It takes the input value 'x' and maps it from the input range (in_min to in_max)
// to the output range (out_min to out_max).
float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}



















/*
 * Copyright (c) 2024, lraton 
 * All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

// Function that handles the 'BadUSB' feature.
// It selects which submenu option to execute based on the variable `sceltaSubMenu`.
void badusb() {
  type = 1;                 // Sets a global variable to indicate 'BadUSB' operation
  switch (sceltaSubMenu) {  // Switch based on the selected submenu option
    case 0:
      subMenuDisplay();  // Display the submenu for selection
      break;
    case 1:
      selectedbadusb();  // Show the selected 'BadUSB' file
      break;
    case 2:
      sdMenuDisplay(1);  // Display the SD card menu for 'BadUSB' files
      break;
  }
}

// Function to display selected 'BadUSB' file and handle its visual layout
void selectedbadusb() {
  graficausb();   // Set up the graphical user interface for the 'BadUSB' screen
  if (sdbegin) {  // Check if the SD card is initialized
    display.setCursor(33, 30);
    display.println(String(selectedFile));  // Display the name of the selected file
  } else {
    display.setCursor(33, 30);
    display.println("SD Error...");  // Show an error if SD card initialization fails
  }
  battery();             // Display battery status
  checkModuleButton(1);  // Check for button press events in module 1
}

// Function to emulate 'BadUSB' behavior by reading commands from a file and sending them as keyboard inputs
void emulateUsb() {
  graficausb();                                                  // Display the 'BadUSB' graphics
  String DEFAULT_FILE_NAME = "/badusb/" + String(selectedFile);  // Path to the selected 'BadUSB' file
  if (sdbegin) {                                                 // Check if SD card is initialized
    display.setCursor(33, 30);
    display.println("Sending...");  // Show "Sending..." while emulating
  } else {
    display.setCursor(33, 30);
    display.println("SD Error...");  // Display error if SD card fails
  }
  battery();  // Display battery status

  file = SD.open(DEFAULT_FILE_NAME);  // Open the selected file from the SD card
  if (file) {                         // If the file is successfully opened
    Keyboard.begin();                 // Begin keyboard emulation

    String line = "";             // Variable to store each line from the file
    while (file.available()) {    // Loop through the file until the end
      char m = file.read();       // Read each character from the file
      if (m == '\n') {            // If newline character is found, process the line
        Line(line);               // Process the current line
        line = "";                // Clear the line variable for the next line
      } else if ((int)m != 13) {  // Ignore carriage return character (13 in ASCII)
        line += m;                // Append character to the current line
      }
    }
    Line(line);  // Process the last line after reading the file

    file.close();  // Close the file after reading
  }
  Keyboard.end();  // End keyboard emulation
}

// Function to process each line of the 'BadUSB' script and execute corresponding keyboard commands
void Line(String l) {
  int space_1 = l.indexOf(" ");                        // Find the first space in the line
  if (space_1 == -1) {                                 // If no space is found, treat the entire line as a single command
    Press(l);                                          // Press the corresponding key for the command
  } else if (l.substring(0, space_1) == "STRING") {    // If command is "STRING", print the remaining text as keyboard input
    Keyboard.print(l.substring(space_1 + 1));          // Type the string after "STRING"
  } else if (l.substring(0, space_1) == "DELAY") {     // If command is "DELAY", pause for the specified time
    int delaytime = l.substring(space_1 + 1).toInt();  // Convert delay value to an integer
    delay(delaytime);                                  // Delay for the specified time
  } else if (l.substring(0, space_1) == "REM") {
    // Ignore "REM" (comment) lines
  } else {
    String remain = l;  // Handle multiple key presses in a line

    // Process the line by breaking it into individual key presses
    while (remain.length() > 0) {
      int latest_space = remain.indexOf(" ");  // Find the next space to split the commands
      if (latest_space == -1) {                // If no space is found, press the remaining part
        Press(remain);                         // Execute the key press
        remain = "";                           // Clear the string
      } else {
        Press(remain.substring(0, latest_space));     // Press the key before the space
        remain = remain.substring(latest_space + 1);  // Update the remaining part of the string
      }
      delay(5);  // Add a small delay between each key press
    }
  }
  battery();              // Display battery status after each line
  Keyboard.releaseAll();  // Release all pressed keys after processing the line
}

// Function to simulate pressing a key or combination of keys based on the string input
void Press(String b) {
  if (b.length() == 1) {  // If the input is a single character
    char c = b[0];        // Get the character
    Keyboard.press(c);    // Press the corresponding key
  } else if (b.equals("ENTER")) {
    Keyboard.press(KEY_RETURN);  // Press the 'Enter' key
  } else if (b.equals("CTRL")) {
    Keyboard.press(KEY_LEFT_CTRL);  // Press the 'Ctrl' key
  } else if (b.equals("SHIFT")) {
    Keyboard.press(KEY_LEFT_SHIFT);  // Press the 'Shift' key
  } else if (b.equals("ALT")) {
    Keyboard.press(KEY_LEFT_ALT);  // Press the 'Alt' key
  } else if (b.equals("GUI")) {
    Keyboard.press(KEY_LEFT_GUI);  // Press the 'GUI' (Windows or Command) key
  } else if (b.equals("UP") || b.equals("UPARROW")) {
    Keyboard.press(KEY_UP_ARROW);  // Press the 'Up Arrow' key
  } else if (b.equals("DOWN") || b.equals("DOWNARROW")) {
    Keyboard.press(KEY_DOWN_ARROW);  // Press the 'Down Arrow' key
  } else if (b.equals("LEFT") || b.equals("LEFTARROW")) {
    Keyboard.press(KEY_LEFT_ARROW);  // Press the 'Left Arrow' key
  } else if (b.equals("RIGHT") || b.equals("RIGHTARROW")) {
    Keyboard.press(KEY_RIGHT_ARROW);  // Press the 'Right Arrow' key
  } else if (b.equals("DELETE")) {
    Keyboard.press(KEY_DELETE);  // Press the 'Delete' key
  } else if (b.equals("PAGEUP")) {
    Keyboard.press(KEY_PAGE_UP);  // Press the 'Page Up' key
  } else if (b.equals("PAGEDOWN")) {
    Keyboard.press(KEY_PAGE_DOWN);  // Press the 'Page Down' key
  } else if (b.equals("HOME")) {
    Keyboard.press(KEY_HOME);  // Press the 'Home' key
  } else if (b.equals("ESC")) {
    Keyboard.press(KEY_ESC);  // Press the 'Escape' key
  } else if (b.equals("INSERT")) {
    Keyboard.press(KEY_INSERT);  // Press the 'Insert' key
  } else if (b.equals("TAB")) {
    Keyboard.press(KEY_TAB);  // Press the 'Tab' key
  } else if (b.equals("END")) {
    Keyboard.press(KEY_END);  // Press the 'End' key
  } else if (b.equals("CAPSLOCK")) {
    Keyboard.press(KEY_CAPS_LOCK);  // Press the 'Caps Lock' key
  } else if (b.equals("F1")) {
    Keyboard.press(KEY_F1);  // Press the 'F1' key
  } else if (b.equals("F2")) {
    Keyboard.press(KEY_F2);  // Press the 'F2' key
  } else if (b.equals("F3")) {
    Keyboard.press(KEY_F3);  // Press the 'F3' key
  } else if (b.equals("F4")) {
    Keyboard.press(KEY_F4);  // Press the 'F4' key
  } else if (b.equals("F5")) {
    Keyboard.press(KEY_F5);  // Press the 'F5' key
  } else if (b.equals("F6")) {
    Keyboard.press(KEY_F6);  // Press the 'F6' key
  } else if (b.equals("F7")) {
    Keyboard.press(KEY_F7);  // Press the 'F7' key
  } else if (b.equals("F8")) {
    Keyboard.press(KEY_F8);  // Press the 'F8' key
  } else if (b.equals("F9")) {
    Keyboard.press(KEY_F9);  // Press the 'F9' key
  } else if (b.equals("F10")) {
    Keyboard.press(KEY_F10);  // Press the 'F10' key
  } else if (b.equals("F11")) {
    Keyboard.press(KEY_F11);  // Press the 'F11' key
  } else if (b.equals("F12")) {
    Keyboard.press(KEY_F12);  // Press the 'F12' key
  } else if (b.equals("SPACE")) {
    Keyboard.press(' ');  // Press the spacebar
  }
}
